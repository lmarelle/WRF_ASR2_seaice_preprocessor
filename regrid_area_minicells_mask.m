function [regridded_data]=regrid_area_minicells_mask(input_data, mapping_array, input_mask)
%
% 2017/12/6, Louis Marelle, for CICERO
%
% -------- Regrids per-area (e.g. in kg/m2) or intensive (e.g., temperature) --------
% -------- data from one grid to another, ignores input cells       --------
% -------- indicated by input_mask --------
%
% Note: this is probably not specific to a WRF grid -> lat/lon grid mapping, test this later
%
% Variables: 
%
% - Input
% input_data: any 2D array on the input grid containing data in per-area units, 
%   or corresponding to an intensive property (e.g., temperature)
% mapping_regrid: cell array containing the mapping from the input grid to the 
%   output grid mapping. mapping_regridis the same dimensions than the 
%   destination grid, and each element mapping_regrid(i, j) contains a string
%   of locations i0 j0 i1 j1 ... of minicells from the input grid that map to 
%   (i, j). This has to be generated by the corresponding 
%   map_regrid_minicells_* routine.
% input_mask: data mask (1 for valid, 0 for invalid), indicating which input
%   grid cells should be ignored by the regridding
% 
% - Output
% regridded_data: input_data regridded to the output grid
%
% - Local variables of interest
% regridded_data_sum, regridded_data_counter: In order to regrid per-area or 
%   intensive data, we perform an average (sum/N; or regridded_data_sum./regridded_data_counter) 
%   of the data from the N input minicells mapping to a given output grid cell.
% mapping_ij: element {ii, jj} of the mapping array, containing the mapping
%   to length(mapping_ij)/2 input grid minicells (i0, j0, i1, j1 ...)
% pos_map_el: position (1, 3, 5 ...) of one of the minicell elements i_n in 
%   mapping_ij. mapping_ij(pos_map_el:pos_map_el+1) => (i_n, j_n)


%---- Check inputs
% Input mask and input data should be the same dimension
if(size(input_data) ~= size(input_mask))
  error('Error, input data and input data mask should be the same size')
end


%---- Initialize
[imax, jmax] = size(mapping_array);
regridded_data_sum = zeros(imax, jmax); 
regridded_data_counter = zeros(imax, jmax);


%---- loop on output grid cells & regrid
for ii = 1:imax
  for jj = 1:jmax

    if(~isempty(mapping_array{ii, jj})) % If some input grid cells map to output cell (ii, jj)
      mapping_ij = mapping_array{ii, jj};

      for pos_map_el = 1:2:length(mapping_ij)
        if(input_mask(mapping_ij(pos_map_el), mapping_ij(pos_map_el + 1))) % Only consider unmasked points
          % Compute the data sum and counter needed to perform the cell average sum/N below
          regridded_data_sum(ii, jj) = regridded_data_sum(ii, jj) + input_data(mapping_ij(pos_map_el), mapping_ij(pos_map_el + 1));
          regridded_data_counter(ii, jj) =  regridded_data_counter(ii, jj) + 1;
        end
      end

    else % No cell from the input grid corresponds to this output grid cell, return NaN
      regridded_data_sum(ii, jj) = NaN;
    end % ~isempty(mapping_array{ii, jj})

  end % jj
end % ii

% Perform the average, sum/N
regridded_data = regridded_data_sum ./ regridded_data_counter;

end
